"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWeightedSearch = createWeightedSearch;

var _sortBy = _interopRequireDefault(require("lodash/sortBy"));

var _operators = require("rxjs/operators");

var _draftUtils = require("../../util/draftUtils");

var _applyWeights = require("./applyWeights");

var _createSearchQuery2 = require("./createSearchQuery");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getSearchTerms(searchParams, types) {
  if (typeof searchParams === 'string') {
    return {
      query: searchParams,
      types: types
    };
  }

  return searchParams.types.length ? searchParams : _objectSpread(_objectSpread({}, searchParams), {}, {
    types
  });
}

function createWeightedSearch(types, client) {
  var commonOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Search currently supports both strings (reference + cross dataset reference inputs)
  // or a SearchTerms object (omnisearch).
  return function search(searchParams) {
    var searchOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var searchTerms = getSearchTerms(searchParams, types);

    var _createSearchQuery = (0, _createSearchQuery2.createSearchQuery)(searchTerms, _objectSpread(_objectSpread({}, commonOpts), searchOpts)),
        query = _createSearchQuery.query,
        params = _createSearchQuery.params,
        options = _createSearchQuery.options,
        searchSpec = _createSearchQuery.searchSpec,
        terms = _createSearchQuery.terms;

    return client.observable.fetch(query, params, options).pipe(commonOpts.unique ? (0, _operators.map)(_draftUtils.removeDupes) : (0, _operators.tap)(), // Assign weighting and scores based on current search terms.
    // No scores will be assigned when terms are empty.
    (0, _operators.map)(hits => (0, _applyWeights.applyWeights)(searchSpec, hits, terms)), // Optionally skip client-side score sorting.
    // This can be relevant when ordering results by specific fields, especially dates.
    searchOpts !== null && searchOpts !== void 0 && searchOpts.skipSortByScore ? (0, _operators.tap)() : (0, _operators.map)(hits => (0, _sortBy.default)(hits, hit => -hit.score)));
  };
}